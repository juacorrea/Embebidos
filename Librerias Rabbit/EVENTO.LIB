/*** BeginHeader */

#use IO.LIB
#use LED.LIB
#use RTC.LIB



struct Event
{
	int numero;
	char command;
	char param;
	int frec;
	unsigned long time;

} ;

#define PRENDER						1
#define APAGAR					  		0
#define CANTIDAD_EVENTOS			8
#define VACIO							-1

/*** EndHeader */


/*** BeginHeader EVENTO_Menu_Usuario  */
cofunc void EVENTO_Menu_Usuario(struct Event *puntero_evento , char tarea);
/*** EndHeader */
cofunc void EVENTO_Menu_Usuario(struct Event *puntero_evento, char tarea)
{

	int contador_eventos;
	struct tm tiempo_actual;
	unsigned long int time;
	unsigned long int time_evento;

	int i, i_1;
	int frec;
	char x_s [4];
	char x;
	char w_s[4];
	char borrar [15];
	int evento_borrar;
	char error;
	int hay_lugar;
    char led;

	error = 0;



//----------------------------------------------------------------------------
			switch (tarea)
			{
//-------------------------FIJAR HORA ---------------------------------------
/*Espero a que el usuario ingrese los valores correctos para la hora (RTC_WRITE_TIME),
esto me devuelve un valor y ese valor se lo asigno al RT, la funcion devuelve 0, ya que
*/
				case(1):
					wfd time = RTC_WRITE_Time();
					write_rtc (time);
					printf("\n HORA CONFIGURADA\n");
					time = read_rtc();
					mktm ( &tiempo_actual, time);
					printf ("\n Fecha:%d/%d/%d \n Hora %d:%d:%d \n" ,tiempo_actual.tm_mday, tiempo_actual.tm_mon, tiempo_actual.tm_year + 1900, tiempo_actual.tm_hour, tiempo_actual.tm_min, tiempo_actual.tm_sec);

				return  ;
//----------------------------------------------------------------------------
//------------------------LEER HORA--------------------------------------------
/*Lee la hora del RTC, luego transforma ese valor en un estructura tm, y luego imprime en pantalla*/
				case(2):
					time = read_rtc();
					mktm ( &tiempo_actual, time);
					printf ("\n Fecha:%d/%d/%d \n Hora %d:%d:%d \n" ,tiempo_actual.tm_mday, tiempo_actual.tm_mon, tiempo_actual.tm_year + 1900, tiempo_actual.tm_hour, tiempo_actual.tm_min, tiempo_actual.tm_sec);
				return ;
//--------------------------------------------------------------------------------
//-------------------------AGREGAR EVENTO-----------------------------------------
/*Busca un lugar libre para agregar el evento, cuando lo encuentra, el asigna ese valor (i) a
evento.numero, le pide al usuario los datos de evento, que led prender y a que frecuencia,
el usuario puede elegir unicamente un led, de elegir lo contrario, se le pedira que asgine
nuevamente, se utiliza la varibale hay_lugar para determinar si se puede agregar el evento o no
(antes de pedirle al usuario que ingrese todos los datos*/
				case (3):
				hay_lugar = 0;
					for ( i = 0 ; i<(CANTIDAD_EVENTOS); i++)
						{
							if ( puntero_evento->numero == VACIO) //Cuando el lugar esta libre anoto el evento
							{
								i_1 = i;
								wfd time = RTC_WRITE_Time();
								i = i_1;
								puntero_evento->time = time;

								if (time == 0)
								{
									printf ("\n EVENTO NO CONFIGURADO \n");
									puntero_evento->numero = VACIO;
								 return ;
								}

								puntero_evento->numero = i;
								puntero_evento->command = PRENDER;
								printf ("Elija un LED para el evento (Entre 0 Y 7)\n");

								error = 0;
								while (error < 1)
								{
									i_1 = i;
									waitfor (getswf(x_s));
									x = atoi(x_s);
									i = i_1;
									if (x<8 && x>=0)
										{
											puntero_evento->param = x;
											printf("\n\t Led OK\n");
											error = 1;
										}
									else
										{
											printf("\n\t El LED no es valido, ingrese un numero del 0 al 7 \n");
											error = 0;
										}
								}

								printf ("\n Elija frecuencia para prender y apagar el LED (Entre (1-9)*0.1s)\n");
								error = 0;
								while (error <1 )
								{
									i_1 = i;
									waitfor (getswf (w_s));
									frec = atoi (w_s);
									i = i_1;
									//t = 0;
									if (frec <10 && frec >=0)
								   {
										puntero_evento->numero  = i;
										puntero_evento->frec = frec;      // frecuencia con la que desea prender y apagar el led
										printf("\n\t Frecuencia OK\n");
										printf("\n EVENTO %d GUARDADO \t%d\n",puntero_evento->numero,i);
										i = CANTIDAD_EVENTOS;
										hay_lugar = 1;
										error = 1;
								   }
								   else
								   {
									   printf("\n\t LA FRECUENCIA NO ES VÁLIDA, elegir entre (1-9)*0.1s \n");
									   error = 0;
								   }
								}
							}

							puntero_evento ++; //AUMENTO LA DIRECCION DEL PUNTERO A NUMERO
						}

						if (hay_lugar == 0)
						{
							printf("\n NO HAY ESPACIO EN MEMORIA SUFICIENTE  \t\n");
						}
				return  ;
//------------------------------------------------------------------------------------------------------------------
//-----------------------------	BORRAR EVENTO ---------------------------------------------------------------------
/*El usuario tiene que ingresar el numero del evento a borrar,
chequeo que exista un evento en ese lugar (evento.numero != VACIO),
si existe el evento, entonces a evento.numero le asigno el valor de VACIO,
si no existe puede ser porque no hay un evento configurado o porque
exede la cantidad de eventos maxima (CANTIDAD_EVENTOS).*/
				case (4):
					printf("Elija el numero del evento a borrar \n");
					error = 0;
					while (error <1 )
					{
						waitfor (getswf(borrar));
						evento_borrar = atoi(borrar);
						if (evento_borrar < CANTIDAD_EVENTOS && CANTIDAD_EVENTOS>= 0)
						{
							puntero_evento = puntero_evento + evento_borrar; //AUMENTO LA DIRRECCION DEL PUNTERO A LA QUE QUIERE EL USUARIO

							if( puntero_evento->numero != VACIO)
							{
								printf("Evento borrado correctamente\n");
								puntero_evento->numero =  VACIO;
								error = 1;

							}
							else
							{
								printf("No existe evento\n Lista de eventos:");
								for ( i = 0 ; i<CANTIDAD_EVENTOS; i++)
									{
										if (puntero_evento->numero != VACIO)
										{
											time_evento = puntero_evento->time;
											mktm ( &tiempo_actual, time_evento);
											printf("\nEvento %d:\n\tFecha:%d/%d/%d \n\t Hora %d:%d:%d\n\tLed: %d\t Frec.:%d ms\n" ,i,tiempo_actual.tm_mday, tiempo_actual.tm_mon, tiempo_actual.tm_year+1900, tiempo_actual.tm_hour, tiempo_actual.tm_min, tiempo_actual.tm_sec,puntero_evento->param,puntero_evento->frec);
										}
										puntero_evento ++;
									}
								error = 0;
							}
						}
						else
						{
							printf("\n\t El numero de evento no es valido, ingrese uno del 0 al 7 \n");
							return ;
						}
					}
				return ;
//-------------------------------------------------------------------------------
//-------------------------- MOSTRAR EVENTOS-----------------------------------
/*Imprime en pantalla unicamente los eventos que tengan el valor de evento.numero != VACIO*/

            case(5):

               contador_eventos = 0;
               for ( i = 0 ; i<CANTIDAD_EVENTOS; i++)
						{
							if (puntero_evento->numero == VACIO)
							{
								contador_eventos++;
								if(contador_eventos == CANTIDAD_EVENTOS)
								{
									printf("No hay eventos programados");
								}

							}
							if (puntero_evento->numero != VACIO)
							{
								time_evento = puntero_evento->time;
								mktm ( &tiempo_actual, time_evento);
								printf("\nEvento %d:\n\tFecha:%d/%d/%d \n\t Hora %d:%d:%d\n\tLed: %d\t Frec.:%d Hz\n" ,i,tiempo_actual.tm_mday, tiempo_actual.tm_mon, tiempo_actual.tm_year+1900, tiempo_actual.tm_hour, tiempo_actual.tm_min, tiempo_actual.tm_sec,puntero_evento->param,puntero_evento->frec);
							}
							puntero_evento ++;
						}
				return;
//--------------------------ENTRADAS ANALOGICAS-----------------------------------------------
 /*Imprime en pantalla ambas entradas analogicas*/
				case (6):

					printf("Input_0 = %d\n", IO_getAnalogInput( 0 ));
					printf("Input_1 = %d\n", IO_getAnalogInput( 1 ));

				return;

//-------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------

				default:
					printf("ERROR número equivocado\n");
					return;
			}



}